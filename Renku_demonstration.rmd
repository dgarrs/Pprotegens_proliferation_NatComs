---
title: "Changes in structure and assembly of a species-rich soil natural community with contrasting nutrient availability upon establishment of a plant-beneficial Pseudomonas in the wheat rhizosphere"
author: "Daniel Garrido-Sanz (daniel.garridosanz@unil.ch)"
affiliation: "Kell Lab | Department of fundamental microbiology | University of Lausanne"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  rmdformats::html_clean:
    code_folding: hide
    toc: true
    thumbnails: false
    toc_depth: 3
pkgdown:
  as_is: true
---

This is a modification of the code and data analyses from: https://github.com/dgarrs/Pprotegens_proliferation_NatComs
This is intended for being executed on a (Renku)[https://renkulab.io/] session.

Only a few data analyses are included.

For more details, see the original code and publication:
Garrido-Sanz, D., Čaušević, S., Vacheron, J. et al. Changes in structure and assembly of a species-rich soil natural community with contrasting nutrient availability upon establishment of a plant-beneficial Pseudomonas in the wheat rhizosphere. Microbiome 11, 214 (2023). https://doi.org/10.1186/s40168-023-01660-5



# 1. Load required packages

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(data.table)
library(scales)

#install and load other packages
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

BiocManager::install(c("phyloseq", "ggh4x", "agricolae"), ask = FALSE)


library(phyloseq)
library(ggh4x)
library(agricolae)
```

and functions required:
(this avoids having to install several packages in the Renku environment)

```{r}
#phyolosec CSS transformation
# Base-R CSS-like normalization (taxa x samples matrix)
css_like <- function(mat, norm = TRUE, log = TRUE, p = 0.75) {
  mat <- as.matrix(mat)
  storage.mode(mat) <- "double"

  if (!norm) {
    out <- mat
  } else {
    sf <- apply(mat, 2, function(x) {
      x <- x[is.finite(x) & x > 0]
      if (!length(x)) return(NA_real_)
      thr <- as.numeric(stats::quantile(x, probs = p, names = FALSE, na.rm = TRUE))
      sum(x[x <= thr])
    })

    ref <- stats::median(sf, na.rm = TRUE)
    if (!is.finite(ref) || ref <= 0) ref <- 1

    out <- sweep(mat, 2, sf, "/")
    out <- sweep(out, 2, ref, "*")

    bad <- !is.finite(sf) | sf <= 0
    if (any(bad)) out[, bad] <- 0
  }

  if (log) out <- log2(out + 1)
  out
}

phyloseq_transform_css <- function(physeq, norm = TRUE, log = TRUE, p = 0.75) {
  otu <- phyloseq::otu_table(physeq)
  tar <- phyloseq::taxa_are_rows(otu)

  mat <- as(otu, "matrix")
  if (!tar) mat <- t(mat)                 # make it taxa x samples

  otu_norm <- css_like(mat, norm = norm, log = log, p = p)

  # restore original orientation
  if (!tar) otu_norm <- t(otu_norm)

  physeq.tr <- physeq
  phyloseq::otu_table(physeq.tr) <- phyloseq::otu_table(otu_norm, taxa_are_rows = tar)
  physeq.tr
}

#orient_taxa from speedyseq
orient_taxa <- function(x, as) {
  stopifnot(as %in% c("rows", "columns", "cols"))
  if (identical(as, "rows")) {
    if (!taxa_are_rows(x))
      x <- t(x)
  } else {
    if (taxa_are_rows(x))
      x <- t(x)
  }
  x
}

#stat_cor from ggpubr
stat_cor <- function(mapping = NULL, data = NULL,
                     method = "pearson", label.sep = ", ",
                     label.x.npc = "left", label.y.npc = "top",
                     label.x = NULL, label.y = NULL,
                     geom = "text", position = "identity",  na.rm = FALSE, show.legend = NA,
                    inherit.aes = TRUE, ...) {
  layer(
    stat = StatCor, data = data, mapping = mapping, geom = geom,
    position = position, show.legend = show.legend, inherit.aes = inherit.aes,
    params = list(label.x.npc  = label.x.npc , label.y.npc  = label.y.npc,
                  label.x = label.x, label.y = label.y, label.sep = label.sep,
                  method = method, na.rm = na.rm, ...)
  )
}


StatCor<- ggproto("StatCor", Stat,
                  required_aes = c("x", "y"),
                  default_aes = aes(hjust = ..hjust.., vjust = ..vjust..),

                  compute_group = function(data, scales, method, label.x.npc, label.y.npc,
                                           label.x, label.y, label.sep)
                    {
                    if (length(unique(data$x)) < 2) {
                      # Not enough data to perform test
                      return(data.frame())
                    }
                    # Returns a data frame with estimate, p.value, label, method
                    .test <- .cor_test(data$x, data$y, method = method, label.sep = label.sep)
                    # Returns a data frame with label: x, y, hjust, vjust
                    .label.pms <- .label_params(data = data, scales = scales,
                                                label.x.npc = label.x.npc, label.y.npc = label.y.npc,
                                                label.x = label.x, label.y = label.y )
                    cbind(.test, .label.pms)
                  }
)





# Correlation test
#::::::::::::::::::::::::::::::::::::::::
# Returns a data frame: estimatel|p.value|method|label
.cor_test <- function(x, y, method = "pearson", label.sep = ", "){
  .cor <- stats::cor.test(x, y, method = method, exact = FALSE)
  z <- data.frame(estimate = .cor$estimate, p.value = .cor$p.value, method = method)
  pval <- .cor$p.value
  pvaltxt <- ifelse(pval < 2.2e-16, "p < 2.2e-16",
                    paste("p =", signif(pval, 2)))
  cortxt <- paste0("r = ", signif(.cor$estimate, 2),
                   label.sep,  pvaltxt)
  z$label <- cortxt
  z
}

#label_params from ggpubr
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# Helper function for adding annotation to a ggplot
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::


# Get label parameters for each group
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# Returns a data frame with x, y, hjust, vjust
# group.id is the index position of the group in a boxplot for example
.label_params <- function(data, scales, label.x.npc = "left", label.y.npc = "right",
                          label.x = NULL, label.y = NULL, .by = c("group", "panel"),
                          group.id = NULL, ...)
  {

  .by <- match.arg(.by)
  # Check label coordinates for each group
  #:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  if(is.null(group.id))
    group.id <- group.id <- abs(data$group[1])
  label.x.npc <- .group_coord(label.x.npc, group.id)
  label.y.npc <- .group_coord(label.y.npc, group.id)
  label.x <- .group_coord(label.x, group.id)
  label.y <- .group_coord(label.y, group.id)

  .check_npc_coord(label.x.npc, axis = "x")
  .check_npc_coord(label.y.npc, axis = "y")



  if (length(label.x) > 0) {
    x <- label.x
    hjust <- 0.5
  } else if (length(label.x.npc) > 0) {
    if (is.numeric(label.x.npc)) {
      x <- scales$x$dimension()[1] + label.x.npc *
        diff(scales$x$dimension())
      hjust <- 0.5
    } else if (is.character(label.x.npc)) {
      if (label.x.npc == "right") {
        x <- scales$x$dimension()[2]
        hjust <- 1
      } else if (label.x.npc %in% c("center", "centre", "middle")) {
        x <- mean(scales$x$dimension())
        hjust <- 0.5
      } else if (label.x.npc == "left") {
        x <- scales$x$dimension()[1]
        hjust <- 0
      }
    }
  }

  if (length(label.y) > 0) {
    y <- label.y
    vjust <- 0.5
  } else if (length(label.y.npc) > 0) {
    if (is.numeric(label.y.npc)) {
      y <- scales$y$dimension()[1] + label.y.npc *
        diff(scales$y$dimension())
      vjust <- 1.4 * group.id - (0.7 * length(group.id))
    } else if (is.character(label.y.npc)) {
      if (label.y.npc == "bottom") {
        y <- scales$y$dimension()[1]
        vjust <- -1.4 * group.id
      } else if (label.y.npc %in% c("center", "centre", "middle")) {
        y <- mean(scales$y$dimension())
        vjust <- 1.4 * group.id - (0.7 * length(group.id))
      } else if (label.y.npc == "top") {
        y <- scales$y$dimension()[2]
        vjust <- 1.4 * group.id
      }
    }
  }
  if(.by == "panel"){
    hjust <- 0.5
    vjust = 0.5
  }

  data.frame(x = x, y = y, hjust = hjust, vjust = vjust)
}


# Get label parameters by group
# Useful in boxplot, where group.ids is the index of the group: 1, 2, 3, etc
# Useful only when computation is done by panel
.label_params_by_group <- function(..., group.ids){
  purrr::map(group.ids,
             function(group.id, ...){.label_params(..., group.id = group.id)},
             ...) %>%
    dplyr::bind_rows() #%>%
    #dplyr::mutate(x = group.ids)

}



# Check label coordinates for each group
#:::::::::::::::::::::::::::::::::::::::::
# coord.values: label coordinate for each group. If too short, they are recycled.
# group.id the id of groups as returned by ggplot_build()
.group_coord <- function(coord.values, group.id){
  if(!.is_empty(coord.values)){
    coord.values <- ifelse(length(coord.values) >= group.id,
                           coord.values[group.id], coord.values[1])
  }
  coord.values
}


# Check NPC coord
#:::::::::::::::::::::::::::::::::::::::::
# npc: Normalised Parent Coordinates.
#   The origin of the viewport is (0, 0) and the viewport has a width and height of 1 unit.
#   For example, (0.5, 0.5) is the centre of the viewport.
# coord: should be between 0 and 1
# axis: should be "x" or "y"
.check_npc_coord <- function(.coord, axis = c("x", "y")){

  axis <- match.arg(axis)
  if(axis == "x")
    allowed.values <- c('right', 'left', 'center', 'centre', 'middle')
  else if(axis == "y")
    allowed.values <- c( 'bottom', 'top', 'center', 'centre', 'middle')

  .message <- paste0("'*.npc coord for ", axis, " axis should be either a numeric value in [0-1] ",
                     "or a character strings including one of ",
                     .collapse(allowed.values, sep = ", "))

  if(!is.null(.coord)){

    if(is.numeric(.coord)){
      if (any(.coord < 0 | .coord > 1)) {
        stop(.message)
      }
    }
    else if(is.character(.coord)){
      if(!(.coord %in% allowed.values))
        stop(.message)

    }
    else
      stop(.message)
  }
}

# Check if en object is empty
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
.is_empty <- function(x){
  length(x) == 0
}


# Collapse one or two vectors
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
.collapse <- function(x, y = NULL, sep = "."){
  if(missing(y))
    paste(x, collapse = sep)
  else if(is.null(x) & is.null(y))
    return(NULL)
  else if(is.null(x))
    return (as.character(y))
  else if(is.null(y))
    return(as.character(x))
  else
    paste0(x, sep, y)
}

#ggarrange from ggpubr
ggarrange <- function(..., plotlist = NULL, ncol = NULL, nrow = NULL,
                      labels = NULL, label.x = 0, label.y = 1, hjust = -0.5, vjust = 1.5,
                      font.label = list(size = 14, color = "black", face = "bold", family = NULL),
                      align = c("none", "h", "v", "hv"),
                      widths = 1, heights = 1,
                      legend = NULL, common.legend = FALSE, legend.grob = NULL )
  {

  # Open null device to avoid blank page before plot------
  # see cowplot:::as_grob.ggplot
  null_device <- base::getOption("ggpubr.null_device", default = cowplot::pdf_null_device)
  cur_dev <- grDevices::dev.cur()
  # Open null device to avoid blank page before plot
  null_device(width = 6, height = 6)
  null_dev <- grDevices::dev.cur()
  on.exit({
    grDevices::dev.off(null_dev)
    if (cur_dev > 1) grDevices::dev.set(cur_dev)
  })


  plots <- c(list(...), plotlist)
  align <- match.arg(align)
  nb.plots <- length(plots)
  page.layout <- .get_layout(ncol, nrow, nb.plots)
  ncol <- page.layout$ncol
  nrow <- page.layout$nrow
  nb.plots.per.page <- .nbplots_per_page(ncol, nrow)

  if(!is.null(legend.grob))
    common.legend <- TRUE
  if(is.null(legend) & common.legend)
    legend <- "top"
  legend <- .check_legend(legend)
  if(!is.null(legend))
    plots <- purrr::map(
      plots,
      function(x) {if(!is.null(x)) x + theme(legend.position = legend) else x}
      )

  if(common.legend){
    if(is.null(legend.grob))
      legend.grob <- get_legend(plots)
    plots <- purrr::map(
      plots,
      function(x) {if(!is.null(x)) x + theme(legend.position = "none") else x}
    )
  }

  # Split plots over multiple pages
  if(nb.plots > nb.plots.per.page){
    plots <- split(plots, ceiling(seq_along(plots)/nb.plots.per.page))
  }
  # One unique page
  else plots <- list(plots)

  # label arguments
  .lab <- .update_label_pms(font.label, label.x = label.x, label.y = label.y,
                            hjust = hjust, vjust = vjust)

  res <- purrr::map(plots, .plot_grid,
              ncol = ncol, nrow = nrow, labels = labels,
              label_size = .lab$size, label_fontfamily = .lab$family,
              label_fontface = .lab$face, label_colour = .lab$color,
              label_x = .lab$label.x, label_y = .lab$label.y,
              hjust = .lab$hjust, vjust = .lab$vjust, align = align,
              rel_widths = widths, rel_heights = heights,
              legend = legend, common.legend.grob = legend.grob
              )




  if(length(res) == 1) res <- res[[1]]

  class(res) <- c(class(res), "ggarrange")
  res
}



.get_layout <- function(ncol, nrow, nb.plots){
  if(!is.null(ncol) & !is.null(nrow)){}
  else if(!is.null(ncol)){
    if(ncol == 1) nrow = nb.plots
  }
  else if(!is.null(nrow)){
    if(nrow == 1) ncol = nb.plots
  }
  list(ncol = ncol, nrow = nrow)
}

# Compute number of plots per page
.nbplots_per_page <- function(ncol = NULL, nrow = NULL){

  if(!is.null(ncol) & !is.null(nrow))
    ncol * nrow
  else if(!is.null(ncol))
    ncol
  else if(!is.null(nrow))
    nrow
  else Inf
}


.plot_grid <- function(plotlist, legend = "top", common.legend.grob = NULL,  ... ){

  res <- cowplot::plot_grid(plotlist = plotlist, ...)
  if(is.null(common.legend.grob)) return(res)
  else {
    leg <- common.legend.grob
    lheight <- sum(leg$height)
    lwidth <- sum(leg$width)
  }

  arrangeGrob <- gridExtra::arrangeGrob
  unit.c <- grid::unit.c
  .unit <- grid::unit(1, "npc")

  res <- switch(legend,
                top = arrangeGrob(leg, res, ncol = 1,
                                  heights = unit.c(lheight, .unit - lheight)),
                bottom = arrangeGrob(res, leg, ncol = 1,
                                     heights = unit.c(unit(1, "npc") - lheight, lheight)),
                left = arrangeGrob(leg, res, ncol = 2,
                                   widths = unit.c(lwidth, .unit - lwidth)),
                right = arrangeGrob(res, leg, ncol = 2,
                                    widths = unit.c(.unit - lwidth, lwidth))
                )

  p <- cowplot::ggdraw() + cowplot::draw_grob(grid::grobTree(res))
  p

}

# update label parameters for cowplot::plot_grid()
.update_label_pms <- function(font.label,
                             label.x = 0, label.y = 1, hjust = -0.5, vjust = 1.5)
  {

  .font <- list(size = 14, color = "black", face = "bold", family = NULL)
  new.font.names <- names(font.label)
  for(i in new.font.names) .font[[i]] <- font.label[[i]]

  pms <- .font
  list(
    size = pms$size,
    family = pms$family,
    face = pms$face,
    color = pms$color,
    label.x = label.x, label.y = label.y,
    hjust = hjust, vjust = vjust
  )
}


# Check legend argument
.check_legend <- function(legend){

  allowed.values <- c("top", "bottom", "left", "right", "none")

  if(is.null(legend) | is.numeric(legend))
    return(legend)
  else if(is.logical(legend)){
    if(legend) legend <- "top"
    else legend <- "none"
  }
  else if(is.character(legend)){
    legend <- legend[1]
    if(!legend %in% allowed.values)
      stop("Argument legend should be one of ", .collapse(allowed.values, sep = ", "))
  }
  return (legend)
}

get_legend <- function(p, position = NULL){

  if(.is_list(p)){
    continue <- TRUE
    i <- 1
    while(i <= length(p) & continue){
      leg <- .get_legend(p[[i]], position = position)
      if(!is.null(leg)) continue <- FALSE
      i <- i+1
    }
  }
  else{
    leg <- .get_legend(p, position = position)
  }
  leg
}



# Return legend for one plot
.get_legend <- function(p, position = NULL){

  if(is.null(p)) return(NULL)
  if(!is.null(position)){
    p <- p + theme(legend.position = position)
  }
  tmp <- ggplot_gtable(ggplot_build(p))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  if(length(leg) > 0) leg <- tmp$grobs[[leg]]
  else leg <- NULL
  leg
}

# Check if is a list
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
.is_list <- function(x){
  inherits(x, "list")
}
```

# 2. Load DADA2 results and metadata

```{r}
taxa2 = read.table(file="Taxtable_dada2.txt", sep=";", header=T)
taxa2 = column_to_rownames(as.data.frame(taxa2), "X")
#seqtab.nochim2 = read.table(file="ASV_sequences.txt", sep=";", header=T)
seqtab.nochim2 = fread(file="ASV_sequences.txt", sep=";", header=T) #fastes
seqtab.nochim2 = column_to_rownames(as.data.frame(seqtab.nochim2), "V1") #V1 if fread used, X if read.table
rownames(seqtab.nochim2) = gsub("_$", "", rownames(seqtab.nochim2))
```

```{r}
metadata = read.table("metadata.txt", header = T, sep = "\t")
rownames(metadata) = metadata$id_samples
head(metadata)
```

# 3. Create the phyloseq object

```{r, warnings = FALSE, error = FALSE, message = FALSE}
ps <- phyloseq(otu_table(seqtab.nochim2, taxa_are_rows=F), 
               sample_data(metadata), 
               tax_table(as.matrix(taxa2)))

#rename our taxa to a short string.
taxa_names(ps) <- paste0("ASV", seq(ntaxa(ps)))

ps
```

# 4. Identify *P. protegens* CHA0 ASV

We will use the control; only inoculated with CHA0

```{r, message=FALSE, warning=FALSE}
cntCHA0=subset_samples(ps, ComState=="Control")
cntCHA0=filter_taxa(cntCHA0, function(x) sum(x) > 0, TRUE)
cntCHA0= subset_taxa(cntCHA0, Genus=="Pseudomonas")
otu_table(cntCHA0)
tax_table(cntCHA0)
```

```{r}
print(paste0("Pseudomonas protegens CHA0 ASV is: ", colnames(otu_table(cntCHA0)[1,1])))
```

*Note* that ASV names will not correspond to those reported in the paper.

# 5. Phyloseq filtering and normalization

## 5.1 Remove Mitochondria and Chloroplasts and the control used for identify CHA0 ASV.

```{r, warnings = FALSE, error = FALSE}
#Filter out mitochondria, chloroplasts, and remove the control
ps = subset_taxa(ps, Genus!="Mitochondria")
ps = subset_taxa(ps, Genus!="Chloroplast")
ps = subset_samples(ps, ComState !="Control")
ps
```

## 5.2 Prevalence filtering

Adapted from: [Bioconductor Workflow for Microbiome Data Analysis: from raw reads to community analyses](https://f1000research.com/articles/5-1492/v2)

```{r }
prev0 = apply(X = otu_table(ps),
                MARGIN = ifelse(taxa_are_rows(ps), yes = 1, no = 2),
                FUN = function(x){sum(x > 0)})

prevdf = data.frame(Prevalence = prev0,
                      TotalAbundance = taxa_sums(ps),
                      tax_table(ps))

#only for reference, in case we want to filter Phyla that appear less than X times
keepPhyla = table(prevdf$Phylum)[(table(prevdf$Phylum) > 0)]

prevdf1 = subset(prevdf, Phylum %in% names(keepPhyla))

# Define prevalence threshold as 0.5% of total samples
prevalenceThreshold = 0.005 * nsamples(ps)
prevalenceThreshold

# Execute prevalence filter, using `prune_taxa()` function
ps1 = prune_taxa((prev0 > prevalenceThreshold), ps)
ps1

# Filter entries with unidentified Phylum.
ps2 = subset_taxa(ps1, Phylum %in% names(keepPhyla))
ps2

ggplot(prevdf1, aes(TotalAbundance, Prevalence, color = Phylum)) +
  geom_hline(yintercept = prevalenceThreshold, alpha = 0.5, linetype = 2) +
  geom_point(size = 2, alpha = 0.65) +
  scale_y_log10() + scale_x_log10() +
  xlab("Total Abundance") +
  scale_color_manual(values=c("#181C43", "#273582", "#1456BA", "#2A7EBA",
                              "#5F9EBB", "#9CBCC7", "#D6DADD", "#E7D5CF",
                              "#D8A897", "#CA7A5F", "#BA4B31", "#9E1B26",
                              "#6E0E25", "#3C0912"))+
  theme_bw()+
  facet_wrap(~Phylum, nrow = 4)

```


```{r}
print(paste0("Initial #ASVs:", ntaxa(ps), ". #ASVs after prevalence filtering:", ntaxa(ps2), ". #ASVs removed: ", ntaxa(ps)-ntaxa(ps2)))
```

Convert to relative abundance and store for further inspection

```{r}
ps2.prop = transform_sample_counts(ps2, function(x) {x/sum(x)*100})
#write.table(otu_table(ps2.prop), "otu_table_ps2_prop.txt", quote = F, sep = "\t")
```


## 5.3 Normalization

For certain downstream analyses; for example to compare different abundances of taxa between samples, the counts needs to be normalized to account for different sampling efforts, exposures, baselines, etc. We will normalize the samples using the CSS (Cumulative Sum Scaling) introduced in [Paulson et al. 2013](https://doi.org/10.1038/nmeth.2658), where the offset of a sample is the cumulative sum of counts in that sample, up to a quantile determined in a data driven way. Calculates scaling factors as the cumulative sum of ASVs abundances up to a data-derived threshold.

```{r fig.width = 11, fig.height= 11,}
#Ussing the CSS
ps2.css = phyloseq_transform_css(ps2, norm = T, log = F)
ps2.css = orient_taxa(ps2.css, "columns") #change taxa to columns
#and the the TSS (proportion; relative abundance)
ps2.css.prop = transform_sample_counts(ps2.css, function(x) {x/sum(x)*100})
```

# 6. Barplots

Using normalized relative abundances

```{r}
#Represent only the top 100 ASVs
toptax = names(sort(taxa_sums(ps2.css), decreasing=TRUE))[1:100]
ps.toptax = transform_sample_counts(ps2.css, function(x) {x/sum(x)*100})
ps.toptax <- prune_taxa(toptax, ps.toptax)

#Plot at the class level
plot_bar(prune_taxa(toptax, ps2.css.prop), x="id_samples", fill="Class")+
  geom_bar(aes(fill=Class), stat="identity", position="stack")+
  scale_fill_manual(values=c("#181C43", "#273D98", "#166FBB", "#599BBA",
                             "#A8C1CB", "#F0ECEB", "#DBB0A3", "#C8765A",
                             "#B23727", "#7E0E28", "#3C0912"))+
  xlab("") + ylab("Normalized relative abundance (%)") +
  facet_wrap(~ComState+Environment+Inoculant, scales="free_x", ncol = 4) + ggtitle("Class, top 100") +
  theme_bw() + theme(legend.position="right", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```


## 6.1 Barplot of relative abundance of *P. protegens*  CHA0


```{r}
#Filter norm tax table for ASV1148 == species "protegens"
ps2.propCHA0 = subset_taxa(ps2.css.prop, Species=="protegens")

plot_bar(ps2.propCHA0, x="id_samples", fill="Species")+
  geom_bar(aes(fill=Species), stat="identity", position="stack")+
  scale_fill_manual(values="#00cc74")+
  xlab("") + ylab("Relative abundance (%)") +
  facet_wrap(~ComState+Environment+Inoculant, scales="free_x", ncol = 4) + ggtitle("Class, top 100") +
  theme_bw() + 
  theme(legend.position="right", 
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) 

```

## 6.2 Differences in CSS-normalized relative abundance of CHA0 ASV

```{r}
#Subset for CHA0 with the CSS
ps2.propCHA0 = subset_taxa(ps2.css.prop, Species=="protegens")
CHA0_abund = left_join(data.frame(sample_data(ps2.propCHA0)), rownames_to_column(data.frame(otu_table(ps2.propCHA0)), "id_samples"), by=c("id_samples"))

CHA0_abund$StateEnviron = paste0(CHA0_abund$ComState, "_", CHA0_abund$Environment, "_", CHA0_abund$Inoculant)

#stats
kw = agricolae::kruskal(CHA0_abund$ASV4, CHA0_abund$StateEnviron, p.adj = "BH")
kwres = rownames_to_column(kw$groups, var="StateEnviron")


#Function to calculate number of observations
stat_box_data <- function(y, upper_limit = max(log(CHA0_abund$ASV1148)) -max(log(CHA0_abund$ASV1148))*1.75) {
  return( 
    data.frame(
      y = 0.95 * upper_limit,
      label = paste('n =', length(y), '\n')
    )
  )
}


ggplot(CHA0_abund, aes(x=StateEnviron, y=as.numeric(ASV4))) +
  geom_boxplot() +
  geom_jitter(color="#00cc74", size=2, shape=16)+
  xlab("") + ylab("Normalized P. protegens ASV relative abundance (%)")+
  annotate(geom = "text", x=kwres$StateEnviron, y=45, label=kwres$groups)+
    ggtitle("Class abundance", subtitle = paste0("Kruskal-Wallis p-value = ",  kw$statistics$p.chisq))+
  scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x), 
                labels = trans_format("log10", math_format(10^.x))) +
  annotation_logticks(sides = "l") +
  stat_summary(
    fun.data = stat_box_data, 
    geom = "text", 
    hjust = 0.5,
    vjust = 0.9
  ) + 
  theme_bw() + theme(axis.text.x = element_text(angle = 35, vjust =1, hjust=1))
```


## 6.3 Differences at the Class level.

```{r warning=FALSE}
#merge taxa by Class!
Class_glom = tax_glom(ps2.css.prop, taxrank = "Class")

Class_abund = left_join(data.frame(sample_data(Class_glom)), rownames_to_column(data.frame(otu_table(Class_glom)), "id_samples"), by=c("id_samples"))
Class_abund$StateEnviron = paste0(Class_abund$ComState, "_", Class_abund$Environment, "_", Class_abund$Inoculant)
Class_abund$Time = as.character(Class_abund$Time)
Class_abund.melt = Class_abund %>% select(-Replicate, -ng.uL) %>% reshape2::melt(value.name = "value")
Class_tax = as.data.frame(tax_table(Class_glom)) %>% rownames_to_column(var = "asvs")
Class_abundtax = left_join(Class_abund.melt, Class_tax, by=c("variable"="asvs"))
head(Class_abundtax)

#Define top classes:
Class_abundtax_top = filter(Class_abundtax, Class!="Abditibacteria" & Class!="Acidobacteriae" & Class!="Gemmatimonadetes" & 
                Class!="Clostridia" & Class!="Longimicrobia" &
                Class!="Coriobacteriia" &
                Class!="Deinococci" &
                Class!="Myxococcia" &
                Class!="Negativicutes" &
                Class!="Thermoanaerobacteria")

#Plot all, stored in the classp list of plots
classp = list()

for (i in unique(Class_abundtax_top$Class)){
  class_filt = filter(Class_abundtax_top, Class==i)
  kw = agricolae::kruskal(class_filt$value, class_filt$StateEnviron, p.adj = "BH")
  kwres = rownames_to_column(kw$groups, var="StateEnviron")
  classp[[i]] = ggplot(class_filt, aes(x=StateEnviron, y=value))+
    geom_boxplot(width=0.9)+
    geom_jitter(aes(color=Class), size=1.75, shape=16)+
    annotate(geom = "text", x=kwres$StateEnviron, y= max(class_filt$value)*1.2, label=kwres$groups)+
    xlab("") + ylab("ASVs normalized relative abundance (%)")+
    ggtitle("Class abundance", subtitle = paste0("Kruskal-Wallis p-value = ",  kw$statistics$p.chisq))+
    scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x))+
    annotation_logticks(sides = "l") +
    facet_wrap(~Class, nrow = 1)+
    theme_bw() + theme(axis.text.x = element_text(angle = 90, vjust =1, hjust=1))
  
}

classp$Alphaproteobacteria
classp$Bacilli
classp$Gammaproteobacteria
```

## 6.4 Differences in Gammaproteobacteria removing CHA0 counts

P. protegens CHA0 would indeed inflate the gammaproteobacteria relative normalized abundance. If we remove the inoculant counts, would we observe differences in gammaproteobacteria?

```{r}
#Remove CHA0 after normalization
ps2.css_noCHA0 = subset_taxa(ps2.css, Species!="protegens")
ps2.css_noCHA0.prop = transform_sample_counts(ps2.css_noCHA0, function(x) {x/sum(x)*100})

#Frist, merge taxa by Class!
noCHA0_Class_glom = tax_glom(ps2.css_noCHA0.prop, taxrank = "Class")
noCHA0_Class_abund = left_join(data.frame(sample_data(noCHA0_Class_glom)), 
                               rownames_to_column(data.frame(otu_table(noCHA0_Class_glom)), "id_samples"), by=c("id_samples"))
noCHA0_Class_abund$StateEnviron = paste0(noCHA0_Class_abund$ComState, "_", 
                                         noCHA0_Class_abund$Environment, "_", 
                                         noCHA0_Class_abund$Inoculant)
noCHA0_Class_abund$Time = as.character(noCHA0_Class_abund$Time)
noCHA0_Class_abund.melt = noCHA0_Class_abund %>% select(-Replicate, -ng.uL) %>% reshape2::melt(value.name = "abund")
noCHA0_Class_tax = as.data.frame(tax_table(noCHA0_Class_glom)) %>% rownames_to_column(var = "asvs")
noCHA0_Class_abundtax = left_join(noCHA0_Class_abund.melt, noCHA0_Class_tax, by=c("variable"="asvs"))

noCHA0_Class_abundtax_top = filter(noCHA0_Class_abundtax, Class=="Gammaproteobacteria")

#Store results

for (i in unique(noCHA0_Class_abundtax_top$Class)){
  class_filt = filter(noCHA0_Class_abundtax_top, Class==i)
  kw = agricolae::kruskal(class_filt$abund, class_filt$StateEnviron, p.adj = "BH")
  kwres = rownames_to_column(kw$groups, var="StateEnviron")
  classp = ggplot(class_filt, aes(x=StateEnviron, y=abund))+
    geom_boxplot(width=0.9)+
    geom_jitter(aes(color=Class), size=1.5, shape=16)+
    annotate(geom = "text", x=kwres$StateEnviron, y=30, label=kwres$groups)+
    xlab("") + ylab("ASVs normalized relative abundance (%)")+
    ggtitle("Class abundance", subtitle = paste0("Kruskal-Wallis p-value = ",  kw$statistics$p.chisq))+
    scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x))+
    annotation_logticks(sides = "l") +
    facet_wrap(~Class, nrow = 1)+
    theme_bw() + theme(axis.text.x = element_text(angle = 90, vjust =1, hjust=1))
  
  plot(classp)
  
}


```

# 7. Diversity

## 7.1 Diversity indexes

Observed ASVs and Shannon index diversity.

```{r }
#Order by ComState+Environment+Inoculant
order.samples = c("Growing_1_Bulk_CHA0","Growing_5_Bulk_CHA0","Growing_7_Bulk_CHA0","Growing_9_Bulk_CHA0", NULL,
                  "Growing_1_Bulk_noCHA0","Growing_5_Bulk_noCHA0","Growing_7_Bulk_noCHA0","Growing_9_Bulk_noCHA0",
                  "Growing_5_Rhiz_CHA0","Growing_7_Rhiz_CHA0","Growing_9_Rhiz_CHA0",
                  "Growing_5_Rhiz_noCHA0","Growing_7_Rhiz_noCHA0","Growing_9_Rhiz_noCHA0",
                  "Stable_1_Bulk_CHA0","Stable_5_Bulk_CHA0","Stable_7_Bulk_CHA0","Stable_9_Bulk_CHA0",
                  "Stable_1_Bulk_noCHA0","Stable_5_Bulk_noCHA0","Stable_7_Bulk_noCHA0","Stable_9_Bulk_noCHA0",
                  "Stable_5_Rhiz_CHA0","Stable_7_Rhiz_CHA0","Stable_9_Rhiz_CHA0",
                  "Stable_5_Rhiz_noCHA0","Stable_7_Rhiz_noCHA0","Stable_9_Rhiz_noCHA0")

#let's also add the corresponding colors.
order.cols = data.frame("Names"=order.samples) %>% left_join(metadata, by="Names") %>% 
  dplyr::select(-id_samples, -ComState, -Inoculant, -Environment, -Time, -Replicate, -Names_rep) %>% unique()

#Observed ASVs
diver.ob = plot_richness(ps2, x="Names", measures=c("Observed"))+
  geom_bar(position = "identity", stat = "summary", aes(y=value-100), fill="darkgrey")+
  geom_errorbar(stat = "summary", width=0.75, aes(y=value-100)) + 
  geom_jitter(width = 0.2, alpha=0.75, size=1, aes(y=value-100))+
  scale_y_continuous(breaks=c(0,100,200), labels=c(100, 200, 300))+
  facet_wrap(~variable,scales = "free_x", nrow = 1)+
  ggpubr::rotate() +
  theme_bw() + theme(legend.position = "bottom", 
                           axis.text.x = element_text(angle = 90, vjust = 0, hjust=1))

diver.ob$layers = diver.ob$layers[-1]
diver.ob$data$Names <- as.character(diver.ob$data$Names)
diver.ob$data$Names <- factor(diver.ob$data$Names, levels=rev(order.samples))

#calculate shannon independently for better representation
diver.sha = plot_richness(ps2, x="Names", measures=c("Shannon"))+
  geom_bar(position = "identity", stat = "summary", aes(y=value-2), fill="darkgrey")+
  geom_errorbar(stat = "summary", width=0.75, aes(y=value-2)) + 
  geom_jitter(width = 0.2, alpha=0.75, size=1, aes(y=value-2))+
  scale_y_continuous(breaks=c(0.0,0.5,1.0,1.5,2.0), labels=c(2, 2.5, 3,3.5,4))+
  facet_wrap(~variable,scales = "free_x", nrow = 1)+
  ggpubr::rotate() +
  theme_bw() + theme(legend.position = "bottom", 
                           axis.text.x = element_text(angle = 90, vjust = 0, hjust=1))
diver.sha$layers = diver.sha$layers[-1]
diver.sha$data$Names <- as.character(diver.sha$data$Names)
diver.sha$data$Names <- factor(diver.sha$data$Names, levels=rev(order.samples))


diver.ob+theme(legend.position = "", axis.line = element_line())+scale_color_manual(values=rev(order.cols$Cols))
diver.sha+theme(legend.position = "", axis.line = element_line())+scale_color_manual(values=rev(order.cols$Cols))

```

## 7.2 Correlation of diversity vs. time


```{r }
#SHANNON
ggplot(diver.sha$data, aes(x=as.numeric(Time), y=value, color=ComState, fill=ComState)) + geom_point() + ylab("Shannon") +
  xlab("Time (days)") + ggtitle("Spearman correlation")+
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs", k=3), linewidth=0.5) +
  stat_cor(method = "spearman") +
  scale_color_manual(values=c("#28511b", "#ccae00"))+
  scale_x_continuous(breaks = c(1,2,3,4,5,6,7,8,9), labels = c(1,"","","",5,"",7,"",9))+
  scale_fill_manual(values=c("#28511b", "#ccae00"))+
  facet_wrap(~Inoculant+Environment, scales = "free_x")+
  theme_bw()+ theme(axis.line = element_line())


#Observed ASVs
ggplot(diver.ob$data, aes(x=as.numeric(Time), y=value, color=ComState, fill=ComState)) + geom_point() + ylab("Observed ASVs") +
  xlab("Time (days)") + ggtitle("Spearman correlation")+
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs", k=3), linewidth=0.5) +
  stat_cor(method = "spearman") +
  scale_color_manual(values=c("#28511b", "#ccae00"))+
  scale_x_continuous(breaks = c(1,2,3,4,5,6,7,8,9), labels = c(1,"","","",5,"",7,"",9))+
  scale_fill_manual(values=c("#28511b", "#ccae00"))+
  facet_wrap(~Inoculant+Environment, scales = "free_x")+
  theme_bw()+ theme(axis.line = element_line())

```

# 8. NMDS

```{r}
set.seed(1234)
#Individually NMDS by ComState
#Growing
ps2.prop.grw = subset_samples(ps2.prop, ComState =="Growing")
ord.nmds.bray.grw = ordinate(ps2.prop.grw, method="NMDS", distance="bray", k=2, trymax=500)
vegan::stressplot(ord.nmds.bray.grw)
scrs.bray.grw = vegan::scores(ord.nmds.bray.grw, display = 'sites')
scrs.bray.grw <- cbind(as.data.frame(scrs.bray.grw), 
                       Names_rep = ps2.prop.grw@sam_data$Names_rep, 
                       Names = ps2.prop.grw@sam_data$Names, 
                       Inoculant = ps2.prop.grw@sam_data$Inoculant, 
                       ComState = ps2.prop.grw@sam_data$ComState, 
                       Env =ps2.prop.grw@sam_data$Environment)
cen.bray.grw = aggregate(cbind(NMDS1, NMDS2) ~ Names, data = scrs.bray.grw, FUN = mean)
segs.bray.grw = merge(scrs.bray.grw, setNames(cen.bray.grw, c('Names', 'oNMDS1','oNMDS2')),
              by = 'Names', sort = FALSE)

grw = plot_ordination(ps2.prop.grw, ord.nmds.bray.grw, color="Names", title="Bray NMDS | Growing com.") +
  geom_point(alpha=0.1) +
  geom_segment(data = segs.bray.grw, mapping = aes(xend = oNMDS1, yend = oNMDS2), size=0.6, alpha=0.25) +
  geom_point(data = cen.bray.grw, size = 3) +
  geom_hline(yintercept = 0, linetype="dashed", color="grey") +
  geom_vline(xintercept = 0, linetype="dashed", color="grey") +
  scale_color_manual(values=c("#dbd8bf", "#d8bfdc", "#f5edc7", "#f498c1","#c8e8e4", "#d9daea", "#e0d085", "#ea519d","#80cdc1", "#b2abd2", "#be9736", "#d42e92","#35978f", "#8074ad"))+
  annotate("text", size=3, y=-0.07, x=-0.25,
           label = paste0("Stress: ", format(round(ord.nmds.bray.grw$stress, 5))), hjust=0)+
  theme_classic() + theme(legend.position="bottom")

#Stable
ps2.prop.stb = subset_samples(ps2.prop, ComState =="Stable")
ord.nmds.bray.stb = ordinate(ps2.prop.stb, method="NMDS", distance="bray", k=2, trymax=500)
vegan::stressplot(ord.nmds.bray.stb)
scrs.bray.stb = vegan::scores(ord.nmds.bray.stb, display = 'sites')
scrs.bray.stb <- cbind(as.data.frame(scrs.bray.stb), 
                       Names_rep = ps2.prop.stb@sam_data$Names_rep, 
                       Names = ps2.prop.stb@sam_data$Names, 
                       Inoculant = ps2.prop.stb@sam_data$Inoculant, 
                       ComState = ps2.prop.stb@sam_data$ComState, 
                       Env =ps2.prop.stb@sam_data$Environment)
cen.bray.stb = aggregate(cbind(NMDS1, NMDS2) ~ Names, data = scrs.bray.stb, FUN = mean)
segs.bray.stb = merge(scrs.bray.stb, setNames(cen.bray.stb, c('Names', 'oNMDS1','oNMDS2')),
              by = 'Names', sort = FALSE)

stb = plot_ordination(ps2.prop.stb, ord.nmds.bray.stb, color="Names", title="Bray NMDS | Stable com.") +
  geom_point(alpha=0.1) +
  geom_segment(data = segs.bray.stb, mapping = aes(xend = oNMDS1, yend = oNMDS2), size=0.6, alpha=0.25) +
  geom_point(data = cen.bray.stb, size = 3) +
  geom_hline(yintercept = 0, linetype="dashed", color="grey") +
  geom_vline(xintercept = 0, linetype="dashed", color="grey") +
  scale_color_manual(values=c("#c39fcb", "#ddbfb8", "#fce0ec", "#fddbc7","#e6f1d0", "#d1e5ef", "#edb5d3", "#f4a582","#b9d987", "#93c5de", "#dd77ae", "#d6604d","#80bc42", "#4393c3"))+
  annotate("text", size=3, y=-0.07, x=-0.25,
           label = paste0("Stress: ", format(round(ord.nmds.bray.stb$stress, 5))), hjust=0)+
  theme_classic() + theme(legend.position="bottom")

grw
stb

```

Calculate density graphs for the Stable/Growing conditions to better see differences:

```{r}
#Growing density plots per NMDS
grw.den.1 = ggplot(scrs.bray.grw, aes(x=NMDS1,color=Names, fill=Names)) +
  geom_density(alpha=0.5) +
  scale_fill_manual(values=c("#dbd8bf", "#d8bfdc", "#f5edc7", "#f498c1",
                             "#c8e8e4", "#d9daea", "#e0d085", "#ea519d",
                             "#80cdc1", "#b2abd2", "#be9736", "#d42e92",
                             "#35978f", "#8074ad"))+
  scale_color_manual(values=c("#dbd8bf", "#d8bfdc", "#f5edc7", "#f498c1",
                              "#c8e8e4", "#d9daea", "#e0d085", "#ea519d", 
                              "#80cdc1", "#b2abd2", "#be9736", "#d42e92",
                              "#35978f", "#8074ad"))+
  theme_classic() + theme(legend.position="none")

grw.den.2 = ggplot(scrs.bray.grw, aes(y=NMDS2,color=Names, fill=Names)) +
  geom_density(alpha=0.5) +
  scale_fill_manual(values=c("#dbd8bf", "#d8bfdc", "#f5edc7", "#f498c1",
                             "#c8e8e4", "#d9daea", "#e0d085", "#ea519d",
                             "#80cdc1", "#b2abd2", "#be9736", "#d42e92",
                             "#35978f", "#8074ad"))+
  scale_color_manual(values=c("#dbd8bf", "#d8bfdc", "#f5edc7", "#f498c1",
                              "#c8e8e4", "#d9daea", "#e0d085", "#ea519d",
                              "#80cdc1", "#b2abd2", "#be9736", "#d42e92",
                              "#35978f", "#8074ad"))+
  theme_classic()+ theme(legend.position="none")


#Stable density plots per NMDS
stb.den.1 = ggplot(scrs.bray.stb, aes(x=NMDS1,color=Names, fill=Names)) +
  geom_density(alpha=0.5) +
  scale_fill_manual(values=c("#c39fcb", "#ddbfb8", "#fce0ec", "#fddbc7",
                             "#e6f1d0", "#d1e5ef", "#edb5d3", "#f4a582",
                             "#b9d987", "#93c5de", "#dd77ae", "#d6604d",
                             "#80bc42", "#4393c3"))+
  scale_color_manual(values=c("#c39fcb", "#ddbfb8", "#fce0ec", "#fddbc7",
                              "#e6f1d0", "#d1e5ef", "#edb5d3", "#f4a582",
                              "#b9d987", "#93c5de", "#dd77ae", "#d6604d",
                              "#80bc42", "#4393c3"))+
  theme_classic()+ theme(legend.position="none")

stb.den.2 = ggplot(scrs.bray.stb, aes(y=NMDS2,color=Names, fill=Names)) +
  geom_density(alpha=0.5) +
  scale_fill_manual(values=c("#c39fcb", "#ddbfb8", "#fce0ec", "#fddbc7",
                             "#e6f1d0", "#d1e5ef", "#edb5d3", "#f4a582",
                             "#b9d987", "#93c5de", "#dd77ae", "#d6604d",
                             "#80bc42", "#4393c3"))+
  scale_color_manual(values=c("#c39fcb", "#ddbfb8", "#fce0ec", "#fddbc7",
                              "#e6f1d0", "#d1e5ef", "#edb5d3", "#f4a582",
                              "#b9d987", "#93c5de", "#dd77ae", "#d6604d",
                              "#80bc42", "#4393c3"))+
  theme_classic()+ theme(legend.position="none")


#And plot both
ggarrange(ggarrange(stb.den.1+xlab("") +theme(axis.text.x=element_blank()) + theme_classic(), 
                              NA, 
                              stb + theme(legend.position="none") + ggtitle("Stable"), 
                              stb.den.2+ylab("") +theme(axis.text.y=element_blank())+ theme_classic(), 
                              ncol=2, nrow = 2, 
                              heights = c(0.85, 2),
                              widths  = c(2, 0.85),
                              align = "hv", 
                              common.legend = TRUE, legend = "right"))


ggarrange(ggarrange(grw.den.1+xlab("") +theme(axis.text.x=element_blank()) + theme_classic(), 
                              NA, 
                              grw + theme(legend.position="none") + ggtitle("Growing"), 
                              grw.den.2+ylab("") +theme(axis.text.y=element_blank())+ theme_classic(), 
                              ncol=2, nrow = 2, 
                              heights = c(0.85, 2),
                              widths  = c(2, 0.85),
                              align = "hv", 
                              common.legend = TRUE, legend = "right"))

```


## 8.1 Distance to the centroid

```{r}
#Growing NatCom
cenbeta.grw = vegan::betadisper(phyloseq::distance(ps2.prop.grw, "bray"), 
                            as.factor(scrs.bray.grw$Names), 
                            type = "centroid", sqrt.dist = F, bias.adjust = T)
cenbeta.grw = as.data.frame(cenbeta.grw$distances)
colnames(cenbeta.grw) = "distances"
cenbeta.grw = rownames_to_column(cenbeta.grw, "id_samples") %>% left_join(metadata, by="id_samples")

cen.dist.grw.plot = ggplot(cenbeta.grw, aes(x=Names, y=distances)) + 
  geom_bar(position = "identity", stat = "summary", fill="darkgrey") + 
  ggtitle("Growng NatCom")+
  geom_errorbar(stat="summary", width=0.5)+
  geom_jitter(shape=16, width = 0.2) +
  theme_classic() + ylab("Distance to centroid") +
  facet_wrap(~Environment+Inoculant, scales = "free_x", ncol = 4)+
  theme(axis.line = element_line(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

#Stable NatCom
cenbeta.stb = vegan::betadisper(phyloseq::distance(ps2.prop.stb, "bray"), 
                            as.factor(scrs.bray.stb$Names), 
                            type = "centroid", sqrt.dist = F, bias.adjust = T)
cenbeta.stb = as.data.frame(cenbeta.stb$distances)
colnames(cenbeta.stb) = "distances"
cenbeta.stb = rownames_to_column(cenbeta.stb, "id_samples") %>% left_join(metadata, by="id_samples")

cen.dist.stb.plot = ggplot(cenbeta.stb, aes(x=Names, y=distances)) + 
  geom_bar(position = "identity", stat = "summary", fill="darkgrey") + 
  ggtitle("Stable NatCom")+
  geom_errorbar(stat="summary", width=0.5)+
  geom_jitter(shape=16, width = 0.2) +
  theme_classic() + ylab("Distance to centroid") +
  facet_wrap(~Environment+Inoculant, scales = "free_x", ncol = 4)+
  theme(axis.line = element_line(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

ggarrange(cen.dist.grw.plot, cen.dist.stb.plot, nrow = 1)
```

## 8.2 Bray-Curtis statistical differences

Test for homogeneity of the data

```{r}
bray.rep=phyloseq::distance(ps2.prop, method="bray")
sampledf = data.frame(sample_data(ps2.prop))

set.seed(1234)
vegan::permutest(vegan::betadisper(bray.rep, sampledf$Names))
```

Our data is in the limit of being homogeneously dispersed. ANOVA is generally robust to violations of the assumption (homogeneity) as long as group sizes are equal. Group sizes are indeed equal. Therefore we will use PERMANOVA (permutational multivariate ANOVA (analysis of variance) and also kruskal in case there are discrepancies.

### 8.2.1 Growing vs. Stable communities?

```{r}
#Are grow/Stable are different?
vegan::adonis2(formula = bray.rep ~ ps2.prop@sam_data$ComState, data = sampledf, permutations = 9999)
kruskal.test(ps2.prop@sam_data$ComState ~ ps2.prop@sam_data$Names, data=as.matrix(bray.rep))
```

Yes, there are.

### 8.2.2 Bulk vs. Rhizosphere


```{r}
#Obtain bray-curtis distances of the growing community
bray.grw=phyloseq::distance(ps2.prop.grw, method="bray")
sampledf.grw = data.frame(sample_data(ps2.prop.grw))

#Obtain bray-curtis distances of the Stable community
bray.stb=phyloseq::distance(ps2.prop.stb, method="bray")
sampledf.stb = data.frame(sample_data(ps2.prop.stb))

#Are Bulk / Rhizosphere different in growing?
vegan::adonis2(formula = bray.grw ~ ps2.prop.grw@sam_data$Environment, data = sampledf.grw, permutations = 9999)
kruskal.test(ps2.prop.grw@sam_data$Environment ~ ps2.prop.grw@sam_data$Names, data=as.matrix(bray.grw))
#Are inoculated no inoculated different in Stable?
vegan::adonis2(formula = bray.stb ~ ps2.prop.stb@sam_data$Environment, data = sampledf.stb, permutations = 9999)
kruskal.test(ps2.prop.stb@sam_data$Environment ~ ps2.prop.stb@sam_data$Names, data=as.matrix(bray.stb))
```

Yes. In both cases, there are differences between bulk and rhizosphere conditions, in the growing or stable NatCom.

### 8.2.3 Inocualted vs. not inoculate in each ComState and Environment

Are there differences between inoculated or non-inoculated within each community state (growing and Stable) and depending if we consider the Rhizosphere or the Bulk?

```{r}
#Are inoculated no inoculated different in GROWING?
vegan::adonis2(formula = bray.grw ~ ps2.prop.grw@sam_data$Inoculant * ps2.prop.grw@sam_data$Environment, data = sampledf.grw, permutations = 9999)

#Are inoculated no inoculated different in Stable?
vegan::adonis2(formula = bray.stb ~ ps2.prop.stb@sam_data$Inoculant * ps2.prop.stb@sam_data$Environment, data = sampledf.stb, permutations = 9999)
```

## 8.3 Correlation of Bray-Curtis vs. time

First transform the Bray-Curtis dissimilarity matrix among samples into long format; sample1 sample2 and value of Bray-Curtis. Remove diagonals and add the metadata per comparison

```{r}
bray.rep=phyloseq::distance(ps2.prop, method="bray")
sampledf = data.frame(sample_data(ps2.prop))
bray.rep.melt = reshape2::melt(as.matrix(bray.rep))
colnames(bray.rep.melt) = c("sample1", "sample2", "BC_diss")
head(bray.rep.melt)

bray.rep.info = bray.rep.melt %>% left_join(sampledf, by=c("sample1"="id_samples")) %>% 
  left_join(sampledf, by=c("sample2"="id_samples"))

#remove diagonals
bray.rep.info = bray.rep.info %>% filter(sample1 != sample2) %>% select(-Replicate.x, -Replicate.y, -ng.uL.x, -ng.uL.y,
                                                                        -Names_rep.x, -Names_rep.y)
```


```{r )}
library(ggpmisc)
ggplot(filter(bray.rep.info, ComState.x == ComState.y & Environment.x == Environment.y & Inoculant.x == Inoculant.y & Time.x == Time.y),
              aes(x=as.numeric(Time.x), y=BC_diss, color=ComState.x, fill=ComState.x)) + 
  geom_point() + ylab("Bray-Curtis dissimilarity") +
  xlab("Time (days)") + ggtitle("Spearman correlation")+
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs", k=3), size=0.5) +
  stat_cor(method = "spearman") +
  scale_color_manual(values=c("#8075ae", "#4393c4"))+
  scale_x_continuous(breaks = c(1,2,3,4,5,6,7,8,9), labels = c(1,"","","",5,"",7,"",9))+
  scale_fill_manual(values=c("#8075ae", "#4393c4"))+
  facet_wrap(~Inoculant.x+Environment.x, scales = "free_x")+
  theme_classic()+ theme(axis.line = element_line())
```



# 9. *Pseudomonas*

## 9.1 Relative abundance of top 5 *Pseudomonas* ASVs

```{r}
ps2.prop = transform_sample_counts(ps2, function(x) {x/sum(x)*100})
#Filter tax table for Pseudomonas ASVs
ps2.propPseudo = subset_taxa(ps2.prop, Genus=="Pseudomonas")

#retrieve top 5
toptax.Pseudo = names(sort(taxa_sums(ps2.propPseudo), decreasing=TRUE))[1:5]
ps.toptax.Pseudo = prune_taxa(toptax.Pseudo, ps2.propPseudo)

Pseudo = as.data.frame(otu_table(ps.toptax.Pseudo))
Pseudo = rownames_to_column(Pseudo, "id_samples")
Pseudo.melt = reshape2::melt(Pseudo)
Pseudo.melt = Pseudo.melt %>% left_join(data.frame(sample_data(ps2.propPseudo)), by="id_samples")

ggplot(filter(Pseudo.melt, Time %in% c(1,9)), aes(x=Names, y=value/4))+
  geom_bar(aes(fill=variable), stat="identity")+ ylab("Normalized relative abundance")+
  scale_fill_manual(values=c("#e0bd89", "#31a872", "#3b79bc", "purple", "#c42c2c"))+
  facet_grid(~ComState+Inoculant+Environment, scales="free_x")+
  theme_classic() + theme(legend.position="right", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) 

```

## 9.2 Differences in relative abundance of *Pseudomonas*

```{r}
ps2.css.propPseudo = subset_taxa(ps2.css.prop, Genus=="Pseudomonas")
#Write all pseudomonas refseqs:
#write.table(refseq(ps2.css.propPseudo), "ref-seq_PSEUDO_all.txt", sep = "\t", quote = F, col.names = F)

#retrieve top 5
toptax.css.Pseudo = names(sort(taxa_sums(ps2.css.propPseudo), decreasing=TRUE))[1:5]
ps.css.toptax.Pseudo = prune_taxa(toptax.css.Pseudo, ps2.css.propPseudo)

Pseudo.css = as.data.frame(otu_table(ps.css.toptax.Pseudo))
Pseudo.css = rownames_to_column(Pseudo.css, "id_samples")
Pseudo.css.melt = reshape2::melt(Pseudo.css)
Pseudo.css.melt = Pseudo.css.melt %>% 
  left_join(data.frame(sample_data(ps2.css.propPseudo)), by= "id_samples")
head(Pseudo.css.melt)
```


```{r warning=FALSE}
toptax.css.Pseudo = as.character(unlist(toptax.css.Pseudo, use.names = FALSE))
Pseudo.melt.filtered = filter(Pseudo.css.melt, variable %in% toptax.css.Pseudo & Time %in% c(1,9))

cols = c("#e0bd89", "#31a872", "#3b79bc", "purple", "#c42c2c")

plots_ps = list()

for (k in seq_along(toptax.css.Pseudo)){
  i = toptax.css.Pseudo[k]
  pseudo_name = i
  df = filter(Pseudo.melt.filtered, variable == i)
  kw = agricolae::kruskal(df$value, df$Names, p.adj = "BH")
  kwres = rownames_to_column(kw$groups, var="StateEnviron")
  
  plots_ps[[i]] = ggplot(df, aes(x=Names, y=value)) +
  geom_segment(aes(y = value, yend = 0, xend=Names), stat = "summary", 
               position = "identity", width = 0.7, fun = mean, 
               size = 15, color = cols[(k-1) %% length(cols) + 1])+
  geom_jitter(shape=16, width = 0.2)+
  annotate(geom = "text", x=kwres$StateEnviron, y=100, label=kwres$groups)+
  xlab("Sampling time (days)") + ylab("Normalized relative abundance (%)")+
  ggtitle(paste0("Pseudomonas ASV ", pseudo_name, " abundance"), subtitle = paste0("Kruskal-Wallis p-value = ",  kw$statistics$p.chisq))+
  scale_y_log10(limits = c(0.001, 100),
                breaks = trans_breaks("log10", function(x) 10^x), 
                labels = trans_format("log10", math_format(10^.x))) +
  geom_errorbar(stat="summary", width=0.3) +
  annotation_logticks(sides = "l") +
  theme_bw() + 
  theme(axis.text.x = element_blank())
}

plots_ps

```


